<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Battleships Royale - Setup</title>
    <!--<meta name="description" content="A simple HTML5 Template for new projects.">-->
    <!--<meta name="author" content="SitePoint">-->
    <!--<base href=".">-->
    <link href="./styling/stylesheet.css" rel="stylesheet" />
<body>
    <div class='bsr'>
        <div class='bsr__nav'>
            <a class="bsr__link bsr__link--active" href="play.html">Play</a>
            <a class="bsr__link bsr__link--inactive" href="leaderboard.html">Leaderboard</a>
            <a class="bsr__link bsr__link--inactive" href="about.html">About</a>
        </div>
        <div class="bsr__menu">
            <div class="bsr__game">
                *32 player limit at the moment*
                <br>
                <button class="bsr__choice bsr__choice--disabled">Join A Match</button>
                <div class="bsr__dropdown bsr__dropdown--disabled">
                    <button type="button" class="bsr__choice bsr__choice--disabled" id="bsr__join">Join Match</button>
                    Got A Code? Enter It Here:
                    <input type="text" class="bsr__code" id="bsr__code" minlength="32" maxlength="32" size="46" placeholder="################################">
                </div>
                <button class="bsr__choice bsr__choice--disabled">Create A Match</button>
                <div class="bsr__dropdown bsr__dropdown--disabled">
                    <label for="bsr_checkbox--ai">A.I. Enabled?</label>
                    <input type="checkbox" class="bsr__checkbox bsr__checkbox--disabled" id="bsr__checkbox--ai" name="bsr__checkbox--ai" value=false>
                    <label for="bsr__checkbox--public">Public Game? (Random people can join)</label>
                    <input type="checkbox" class="bsr__checkbox bsr__checkbox--disabled" id="bsr__checkbox--public" name="bsr__checkbox--public" value=false>
                    <label for="bsr__players--count">A.I. Count</label>
                    <input type="number" class="bsr__players bsr__players--count" id="bsr__players--count" name="bsr__players--count" min=1 max=31 size="3">
                    <br>
                    <button type="button" class="bsr__choice bsr__choice--disabled" id="bsr__prepare">Prepare Game</button>
                    <br>
                    Match will start when countdown is finished or match is manually started...
                    <br>
                    (match time here)
                    <br>
                    Match Code:
                    <br>
                    <button type="button" class="bsr__choice bsr__choice--disabled" id="bsr__start">Start Game</button>
                    <br>

                    <div class="test__drag" id="test__drag" draggable="true" ondragstart="dragBoardPiece(event)">
                        drag stuff
                        = 9 damage
                    </div>
                </div>
            </div>
            <button type="button" id="bsr__rotate">Rotate pieces</button>
            <div class="bsr__piecesshell" id="bsr__piecesshell">

            </div>
            <div id="bsr__count">

            </div>
            <div class="bsr__options" id="bsr__options">

            </div>
            <div class="bsr__players" id="bsr__players">

            </div>
        </div>
        <div class="color">
            test
            <div class="test__color">
                test
                <div class="test__color--border">
                    test 
                </div>
            </div>
        </div>
    </div>
    <div id="bsr__remover">

    </div>
    <div class='test' id="test">

    </div>
    <div id="testt">

    </div>
    <div class="bsr__playerplot bsr__playerplot--empty" id="bsr__playerplot"><img class="bsr__imagepiece" id="bsr__imagepiece"></div>
    <!--
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js">
    </script>
    -->
    <script>

        // pre load all required whole ship scaled pieces
        let carrierh = new Image();    carrierh.src    = "./assets/board-pieces/horizontal/whole/carrierscaled.png";
        let carrierv = new Image();    carrierv.src    = "./assets/board-pieces/vertical/whole/carrierscaled.png";
        let battleshiph = new Image(); battleshiph.src = "./assets/board-pieces/horizontal/whole/battleshipscaled.png";
        let battleshipv = new Image(); battleshipv.src = "./assets/board-pieces/vertical/whole/battleshipscaled.png";
        let destroyerh = new Image();  destroyerh.src  = "./assets/board-pieces/horizontal/whole/destroyerscaled.png";
        let destroyerv = new Image();  destroyerv.src  = "./assets/board-pieces/vertical/whole/destroyerscaled.png";
        let submarineh = new Image();  submarineh.src  = "./assets/board-pieces/horizontal/whole/submarinescaled.png";
        let submarinev = new Image();  submarinev.src  = "./assets/board-pieces/vertical/whole/submarinescaled.png";
        let patrolboath = new Image(); patrolboath.src = "./assets/board-pieces/horizontal/whole/patrolboatscaled.png";
        let patrolboatv = new Image(); patrolboatv.src = "./assets/board-pieces/vertical/whole/patrolboatscaled.png";

        // function to get the proper desired src string
        function getImageSrc(pieceName, rotation){
            if(rotation == 'horizontal'){
                if(pieceName == 'carrier')    return carrierh;
                if(pieceName == 'battleship') return battleshiph;
                if(pieceName == 'destroyer')  return destroyerh;
                if(pieceName == 'submarine')  return submarineh;
                if(pieceName == 'patrolboat') return patrolboath;
            }
            if(rotation == 'vertical'){
                if(pieceName == 'carrier')    return carrierv;
                if(pieceName == 'battleship') return battleshipv;
                if(pieceName == 'destroyer')  return destroyerv;
                if(pieceName == 'submarine')  return submarinev;
                if(pieceName == 'patrolboat') return patrolboatv;
            }
        }


        // set data to transfer over on the use of the drag and drop api
        function allowDropBoardPiece(event) {
            event.preventDefault();
        }

        // on dragging of the board piece
        function dragBoardPiece(event) {
            // get location of image to later show whole piece being picked up
            let imgLocation = event.target.src;
            let imgString = imgLocation.match(/[^\/]+(?=\.png)/g);
            // get string location of image to properly show image in relation to mouse cursor adjustment
            let imgAdjust = imgString.toString().match(/\(.*\)/g);
            imgAdjust = imgAdjust.toString().replace(/\(|\)/g, '');
            var imgXAdjust = imgAdjust.toString().replace(/.+,/g, '');
            var imgYAdjust = imgAdjust.toString().match(/.+(?=,)/g).toString();
            //console.log(imgXAdjust, imgYAdjust);
            // set piece location to adjust to match mouse cliciked piece location
            if(imgXAdjust == 1){
                imgXAdjust = 50;
                imgYAdjust = (imgYAdjust * 100) - 50;
            }
            if(imgYAdjust == 1){
                imgXAdjust = (imgXAdjust * 100) - 50;
                imgYAdjust = 50;
            }
            //console.log(imgXAdjust, imgYAdjust);
            // get piece name and rotation
            let imgRotation = imgLocation.toString().match(/horizontal(?=\/)|vertical(?=\/)/g).toString();
            let imgPieceName = imgString.toString().replace(/-.*/g, '').toString();
            //console.log(imgRotation, imgPieceName);
            let img = getImageSrc(imgPieceName, imgRotation);
            event.dataTransfer.setDragImage(img, imgXAdjust/2, imgYAdjust/2);
            event.dataTransfer.setData("text", event.target.id);
        }

        function dropBoardPiece(event) {
            event.preventDefault();
            var data = event.dataTransfer.getData("text");
        }

    </script>
    <script type="module">
        import {BsrCreateGrids} from "./scripts/bsr-creategrids.js";
        import {Helper} from "./scripts/helper.js";
        import {BsrPlayPieces} from "./scripts/bsr-playpieces.js";
        import {BsrSetup} from "./scripts/bsr-setup.js";

        //--------------------------------------------------------------
        let joinGame = document.getElementById('bsr__join');
        let gameCode = document.getElementById('bsr__code');

        let aiCheckbox = document.getElementById('bsr__checkbox--ai');
        let publicGame = document.getElementById('bsr__checkbox--public');
        let playerCount = document.getElementById('bsr__players--count');
        let prepareGame = document.getElementById('bsr__prepare');
        let startGame = document.getElementById('bsr__start');

        playerCount.onchange = () => {
            if (playerCount.value < 1)
                playerCount.value = 1;
            if (playerCount.value > 31)
                playerCount.value = 31;
        }

        //--------------------------------------------------------------
        
        let testt = document.getElementById("testt");
        let buttonGrid = BsrCreateGrids.getButtonGrid();
        testt.innerHTML = buttonGrid.getGrid();

        testt.innerHTML

        //--------------------------------------------------------------
        let setup = new BsrSetup();
        let gridElement = document.getElementById('test');
        let dragAndDropGrid = setup.getDragAndDropGrid();
        let blankDragAndDropGrid = dragAndDropGrid.getGrid();

        let loadRemover = document.getElementById("bsr__remover").innerHTML = setup.getPieceRemover();

        let combinedPieces = function(){
            let combined = '';
            let pieces = setup.getUpdatedRotatedPieces();
            for (const [key, item] of Object.entries(pieces)){
                combined = combined + item;
            }
            return combined;
        }

        let gridUpdateDragAndDrop = function(){
            document.getElementById("bsr__piecesshell").innerHTML = combinedPieces();
        }

        let loadBlankGrid = function(){
            gridElement.innerHTML = blankDragAndDropGrid;
        }

        let saveDragAndDropGrid = function(){
            dragAndDropGrid.saveGrid(gridElement.innerHTML);
        }

        let reloadDragAndDropGrid = function(){
            gridElement.innerHTML = dragAndDropGrid.loadGrid();
        };

        let loadSetPieces = function(){
            //loadRemover;
            loadBlankGrid();
                let piecesAndPlacement = setup.getPiecesIdsAndInternals();
                //console.log(piecesAndPlacement);
                var piecesAndPlacementLength = piecesAndPlacement.length;
                for (var i = 0; i < piecesAndPlacementLength; i++){
                    let piece = piecesAndPlacement[i];
                    var pieceLength = piece[0].length;
                    for (var j = 0; j < pieceLength; j++){
                        document.getElementById(piece[0][j]).children[0].innerHTML = piece[1][j];
                    }
                }
        }

        gridUpdateDragAndDrop();
        //console.log(setup);
        loadBlankGrid();
        document.getElementById('bsr__rotate').onclick = () => {
            console.log('clicked');
            setup.changeBoardPieceRotation();
            gridUpdateDragAndDrop();
        }

        let canPlacePiece;
        let removedPreviousPiece;
        let tempGrid;
        var time = 10;
        let dragging = false;

        // event on the start of the drag
        document.addEventListener('dragstart', item => {
            //console.log('ran dragstart');
            saveDragAndDropGrid();
            if ((Helper.parseElementIdForMatrixLocation(item.target.parentNode.id)).length == 2){
                setup.setClickedPieceInfo(item.target.parentNode);
            }
        });

        // event to take place on dragging over container pieces
        document.addEventListener('dragover', item => {
            //console.log('ran dragover');
            dragging = true;
            let setDraggedOver = false;
            //console.log(item.target.parentNode.parentNode.parentNode)
            if(item.target.parentNode){
                if(item.target.parentNode.parentNode.parentNode.id != null && !setDraggedOver){
                    if(item.target.parentNode.parentNode.parentNode.id.includes('bsr__table-cell')){
                        setup.setDraggedOverPieceInfo(item.target.parentNode.parentNode);
                        setDraggedOver = true;
                    }
                }
                if(!setDraggedOver){
                    setup.setDraggedOverPieceInfo(item.target);
                }
                setup.checkAndSetPieceLocations();
                canPlacePiece = setup.canUseCurrentLocation();
                //console.log('can place piece', canPlacePiece)
                // if we havent removed previous pieces on pickup of a board piece on the grid
                if (!removedPreviousPiece){
                    let previousPlacement = setup.getPlacedPieceIds();
                    //console.log('previous placement',previousPlacement);
                    if(previousPlacement){
                        var previousPlacementLength = previousPlacement.length;
                        for (var i = 0; i < previousPlacementLength; i++){
                            document.getElementById(previousPlacement[i]).innerHTML = dragAndDropGrid.getDragAndDropCleanInternal();
                        }
                    }
                    // set a temporary grid with the chosen piece removed to show for display
                    tempGrid = gridElement.innerHTML;
                    removedPreviousPiece = true;
                }
                // to update the last pieces we plan on placing on the grid
                if (removedPreviousPiece){
                    let currentPlacement = setup.getDraggedPieceIdsAndInternals();
                    let currentClassName = setup.getDraggedOverPieceClassName();
                    //console.log(currentPlacement);
                    let placementLength = currentPlacement[0].length;
                    for (var i = 0; i < placementLength; i++){
                        if(document.getElementById(currentPlacement[0][i]) != null){
                            if(document.getElementById(currentPlacement[0][i]).children[0] != undefined)
                                document.getElementById(currentPlacement[0][i]).children[0].className = currentClassName;
                        }
                    }
                }
            }
        });

        // if the piece leaves any droppable position, we will have to reload the grid with the temporary grid
        document.addEventListener('dragleave', item => {
            //console.log('ran dragleave');
            dragging = false;
            removedPreviousPiece = false;
            //console.log(setup.getDraggedPieceLocation());
            //console.log(canPlacePiece);
            if (!canPlacePiece || !Helper.checkIfArraysAreEqual(setup.getDraggedPieceLocation(), [0,0])){
                    gridElement.innerHTML = tempGrid;
                    // set a small timer to check if we have stopped dragging the piece or not
                    setTimeout(() => {
                        if (!dragging){
                            reloadDragAndDropGrid();
                        }
                    }, time)
            }
        });

        // on the drop of the piece
        document.addEventListener('drop', item => {
            setup.removePieceIfNeeded();
            setup.setPieceLocationsAndCount();
            document.getElementById("bsr__count").innerHTML = setup.getNumberOfPlayablePiecesLeft().patrolboat;
            console.log(setup.getNumberOfPlayablePiecesLeft());
            gridUpdateDragAndDrop();
            if(!canPlacePiece){
                console.log('using old table');
                reloadDragAndDropGrid();
            }
            if(canPlacePiece || setup.checkIfPieceWasRemoved()){
                loadSetPieces();
            }
            dragging = true;
            removedPreviousPiece = false;
        });


        //bsrPlot.onclick = function(){console.log(grid.onGridPositionClicked(bsrPlot.id))}
        //document.getElementById('testi__cell-(2,2)').innerHTML = testbutton.getHTMLButton();
        //console.log(document.getElementById('generic-button__button').parentElement.id);
        //document.getElementById('test').innerHTML = Helper.getObjectInfo(testtable);
        //console.log(Helper.parseElementIdForMatrixLocation(document.getElementById('testi__cell-(1,1)').id));
        //let testObj1 = {'one': 1, 'objectouter': {'objectinner': {}, 'three': 3}, 'two': 2};
        //let testObj2 = {'objectouter': {'objectinner': {'two' : 2}, 'three': 3}};
        //let testObj3 = {'one' : {'two': 2 ,'three' : {'four' : 4 }}};
        //let testObj4 = {'one' : 1, 'two' : 2, 'three' : {'one' : 1000, 'two' : 2000, 'four' : 4000, 'five' : {'one' : 100}}};

        //console.log(Helper.doesObjectContainProperty(testObj3, 'four'));
        //console.log(Helper.getObjectPropertyByName(testObj4, 'one', true));
        
    </script>
</body>
<hr>
<footer>

</footer>
</html>